package filodb.query.exec

import monix.reactive.Observable

import filodb.core.metadata.Column.ColumnType
import filodb.core.metadata.Dataset
import filodb.core.query.{RangeVector, ResultSchema}
import filodb.query.{AggregationOperator, BinaryOperator, InstantFunctionId}

/**
  * Implementations can provide ways to transform RangeVector
  * results generated by ExecPlan nodes.
  *
  * Reason why these are not ExecPlan nodes themselves is because
  * they can be applied on the same node where the base RangeVectors
  * are sourced.
  *
  * It can safely be assumed that the operations in these nodes are
  * compute intensive and not I/O intensive.
  */
trait RangeVectorTransformer {
  def apply(source: Observable[RangeVector], sourceSchema: ResultSchema): Observable[RangeVector]

  /**
    * Default implementation retains source schema
    */
  def schema(dataset: Dataset, source: ResultSchema): ResultSchema = source

  /**
    * Args to use for the RangeVectorTransformer for printTree purposes only.
    * DO NOT change to a val. Increases heap usage.
    */
  protected[exec] def args: String

}

object RangeVectorTransformer {
  def requireTimeSeries(schema: ResultSchema): Unit = {
    require(schema.isTimeSeries, "Cannot return periodic data from a dataset that is not time series based")
    require(schema.columns.size == 2, "Cannot return periodic data from a dataset that is not time series based")
    require(schema.columns(0).colType == ColumnType.LongColumn,
      "Cannot return periodic data from a dataset that is not time series based")
    require(schema.columns(1).colType == ColumnType.DoubleColumn,
      "Cannot return periodic data from a dataset that is not time series based")
  }
}

/**
  * Applies an instant vector function to every instant/row of the
  * range vectors
  */
final case class InstantVectorFunctionMapper(function: InstantFunctionId,
                                             funcParams: Seq[Any] = Nil) extends RangeVectorTransformer {
  protected[exec] def args: String =
    s"function=$function, funcParams=$funcParams"

  def apply(source: Observable[RangeVector], sourceSchema: ResultSchema): Observable[RangeVector] = ???

  // TODO all function defs go here and get invoked from mapRangeVector
}

/**
  * Applies a binary operation involving a scalar to every instant/row of the
  * range vectors
  */
final case class ScalarOperationMapper(operator: BinaryOperator,
                                       scalar: AnyVal,
                                       scalarOnLhs: Boolean) extends RangeVectorTransformer {
  protected[exec] def args: String =
    s"operator=$operator, scalar=$scalar"

  def apply(source: Observable[RangeVector], sourceSchema: ResultSchema): Observable[RangeVector] = ???

  // TODO all operation defs go here and get invoked from mapRangeVector
}

/**
  * Performs aggregation operation across instants/rows of several RangeVectors
  */
final case class AggregateCombiner(aggrOp: AggregationOperator,
                                   aggrParams: Seq[Any],
                                   without: Seq[String],
                                   by: Seq[String]) extends RangeVectorTransformer {
  protected[exec] def args: String =
    s"aggrOp=$aggrOp, aggrParams=$aggrParams, without=$without, by=$by"

  def apply(source: Observable[RangeVector], sourceSchema: ResultSchema): Observable[RangeVector] = ???

  override def schema(dataset: Dataset, source: ResultSchema): ResultSchema = {
    // TODO Average will not have the same schema
    ???
  }
}

/**
  * Average is typically calculated by aggregating sum and count in a
  * hierarchical tree and finally transforming the sum and count values
  * to average. This mapper precisely does that.
  *
  * Maps "sum" and "count" columns in each range vector to one "average" column
  */
final case class AverageMapper() extends RangeVectorTransformer {
  protected[exec] def args: String = ""

  def apply(source: Observable[RangeVector], sourceSchema: ResultSchema): Observable[RangeVector] = ???

  override def schema(dataset: Dataset, source: ResultSchema): ResultSchema = {
    ???
  }

}
